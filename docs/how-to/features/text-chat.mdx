---
type: how-to
title: Text Chat
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Text Chat

This guide shows how to implement text chat in your application using data channels. Data channels allow you to send and receive arbitrary binary data between peers in a room.

## Prerequisites

Before implementing text chat, you must be [connected to a room](../client/connecting). Data channels only work after you have successfully joined a room.

:::tip
For a deeper understanding of how data channels work, including channel types and broadcast behavior, see [Data Channels](../explanation/data-channels).
:::

---

## Step 1 — Set up the chat hook

Use the [`useDataChannel`](/api/web/functions/useDataChannel) (web) or [`useDataChannel`](/api/mobile/functions/useDataChannel) (mobile) hook to work with data channels. The typical flow is:

1. Initialize the data channel after connecting to a room
2. Subscribe to incoming messages
3. Publish messages to other peers

<Tabs groupId="platform">
  <TabItem value="web" label="React (Web)">

```tsx
import { useConnection, useDataChannel } from "@fishjam-cloud/react-client";
import { useCallback, useEffect, useState } from "react";

export function useChat() {
  const { peerStatus } = useConnection();
  const {
    initializeDataChannel,
    publishData,
    subscribeData,
    dataChannelReady,
  } = useDataChannel();

  const [messages, setMessages] = useState<string[]>([]);

  // Step 1: Initialize data channel when connected
  useEffect(() => {
    if (peerStatus === "connected") {
      initializeDataChannel();
    }
  }, [peerStatus, initializeDataChannel]);

  // Step 2: Subscribe to incoming messages
  useEffect(() => {
    if (!dataChannelReady) return;

    const unsubscribe = subscribeData(
      (data: Uint8Array) => {
        const message = new TextDecoder().decode(data);
        setMessages((prev) => [...prev, message]);
      },
      { reliable: true },
    );

    return unsubscribe;
  }, [subscribeData, dataChannelReady]);

  // Step 3: Publish messages
  const sendMessage = useCallback(
    (text: string) => {
      if (!dataChannelReady) return;

      const encoded = new TextEncoder().encode(text);
      publishData(encoded, { reliable: true });
    },
    [publishData, dataChannelReady],
  );

  return { messages, sendMessage, ready: dataChannelReady };
}
```

  </TabItem>
  <TabItem value="mobile" label="React Native (Mobile)">

```tsx
import { useConnection, useDataChannel } from "@fishjam-cloud/react-native-client";
import { useCallback, useEffect, useState } from "react";

export function useChat() {
  const { peerStatus } = useConnection();
  const {
    initializeDataChannel,
    publishData,
    subscribeData,
    dataChannelReady,
    dataChannelLoading,
    dataChannelError,
  } = useDataChannel();

  const [messages, setMessages] = useState<string[]>([]);

  useEffect(() => {
    if (peerStatus === "connected") {
      initializeDataChannel();
    }
  }, [peerStatus, initializeDataChannel]);

  useEffect(() => {
    if (dataChannelLoading || !dataChannelReady) return;

    const unsubscribe = subscribeData(
      (data: Uint8Array) => {
        const message = new TextDecoder().decode(data);
        setMessages((prev) => [...prev, message]);
      },
      { reliable: true },
    );

    return unsubscribe;
  }, [dataChannelReady, dataChannelLoading, subscribeData]);

  const sendMessage = useCallback(
    (text: string) => {
      if (!dataChannelReady) return;

      const encoded = new TextEncoder().encode(text);
      publishData(encoded, { reliable: true });
    },
    [publishData, dataChannelReady],
  );

  return {
    messages,
    sendMessage,
    ready: dataChannelReady,
    loading: dataChannelLoading,
    error: dataChannelError,
  };
}
```

  </TabItem>
</Tabs>

---

## Step 2 — Use the chat hook in your component

Once you have the hook, you can use it in any component to send and display messages:

<Tabs groupId="platform">
  <TabItem value="web" label="React (Web)">

```tsx
import React from "react";
import { useConnection, useDataChannel } from "@fishjam-cloud/react-client";
import { useCallback, useEffect, useState } from "react";

function useChat() {
  const { peerStatus } = useConnection();
  const {
    initializeDataChannel,
    publishData,
    subscribeData,
    dataChannelReady,
  } = useDataChannel();

  const [messages, setMessages] = useState<string[]>([]);

  useEffect(() => {
    if (peerStatus === "connected") {
      initializeDataChannel();
    }
  }, [peerStatus, initializeDataChannel]);

  useEffect(() => {
    if (!dataChannelReady) return;

    const unsubscribe = subscribeData(
      (data: Uint8Array) => {
        const message = new TextDecoder().decode(data);
        setMessages((prev) => [...prev, message]);
      },
      { reliable: true },
    );

    return unsubscribe;
  }, [subscribeData, dataChannelReady]);

  const sendMessage = useCallback(
    (text: string) => {
      if (!dataChannelReady) return;

      const encoded = new TextEncoder().encode(text);
      publishData(encoded, { reliable: true });
    },
    [publishData, dataChannelReady],
  );

  return { messages, sendMessage, ready: dataChannelReady };
}

// ---cut---

function ChatPanel() {
  const { messages, sendMessage, ready } = useChat();
  const [input, setInput] = useState("");

  const handleSend = () => {
    if (input.trim()) {
      sendMessage(input);
      setInput("");
    }
  };

  if (!ready) {
    return <div>Connecting to chat...</div>;
  }

  return (
    <div>
      <div>
        {messages.map((msg: string, i: number) => (
          <div key={i}>{msg}</div>
        ))}
      </div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyDown={(e) => e.key === "Enter" && handleSend()}
      />
      <button onClick={handleSend}>Send</button>
    </div>
  );
}
```

  </TabItem>
  <TabItem value="mobile" label="React Native (Mobile)">

```tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, Text, TextInput, FlatList, Pressable } from "react-native";
import { useConnection, useDataChannel } from "@fishjam-cloud/react-native-client";

function useChat() {
  const { peerStatus } = useConnection();
  const {
    initializeDataChannel,
    publishData,
    subscribeData,
    dataChannelReady,
  } = useDataChannel();

  const [messages, setMessages] = useState<string[]>([]);

  useEffect(() => {
    if (peerStatus === "connected") {
      initializeDataChannel();
    }
  }, [peerStatus, initializeDataChannel]);

  useEffect(() => {
    if (!dataChannelReady) return;

    const unsubscribe = subscribeData(
      (data: Uint8Array) => {
        const message = new TextDecoder().decode(data);
        setMessages((prev) => [...prev, message]);
      },
      { reliable: true },
    );

    return unsubscribe;
  }, [subscribeData, dataChannelReady]);

  const sendMessage = useCallback(
    (text: string) => {
      if (!dataChannelReady) return;

      const encoded = new TextEncoder().encode(text);
      publishData(encoded, { reliable: true });
    },
    [publishData, dataChannelReady],
  );

  return { messages, sendMessage, ready: dataChannelReady };
}

// ---cut---

function ChatPanel() {
  const { messages, sendMessage, ready } = useChat();
  const [input, setInput] = useState("");

  const handleSend = () => {
    if (input.trim()) {
      sendMessage(input);
      setInput("");
    }
  };

  if (!ready) {
    return <Text>Connecting to chat...</Text>;
  }

  return (
    <View>
      <FlatList
        data={messages}
        keyExtractor={(_, i) => String(i)}
        renderItem={({ item }) => <Text>{item}</Text>}
      />
      <TextInput
        value={input}
        onChangeText={setInput}
        placeholder="Type a message..."
        onSubmitEditing={handleSend}
      />
      <Pressable onPress={handleSend}>
        <Text>Send</Text>
      </Pressable>
    </View>
  );
}
```

  </TabItem>
</Tabs>

---

## Why use the reliable channel?

For chat messages, we use `{ reliable: true }` because:

- **Ordered delivery**: Messages arrive in the order they were sent
- **Guaranteed delivery**: All messages will be delivered, with automatic retransmission if needed

This ensures no chat messages are lost or arrive out of order.

---

## See also

- [Data Channels](../../explanation/data-channels) — detailed explanation of channel types and broadcast behavior
- [Connecting to a room](../../how-to/client/connecting) — prerequisite for using data channels
- [`useDataChannel` API reference (Web)](../../api/web/functions/useDataChannel)
- [`useDataChannel` API reference (Mobile)](../../api/mobile/functions/useDataChannel)
